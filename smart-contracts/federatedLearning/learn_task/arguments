#!/usr/bin/env python3
#
# See: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html

import base64
import re
import struct
import sys
from secrets import token_bytes
from coincurve import PublicKey
from sha3 import keccak_256
from web3 import Web3


def encode_bytes32(value: str) -> str:
    b = value[2:].encode('utf-8')
    # check if the string is too long
    if len(b)/2 > 32.0:
        raise ValueError("The string is too long to be encoded as bytes32.")
        return None
    # pad the string with 0s
    b += b'\x00' * (32 - len(b))
    return b


def encode_uint(value: int) -> str:
    # if value cannot be represented as uint256, raise an error
    if value < 0 or value > 2**256 - 1:
        raise ValueError("The value cannot be represented as uint256.")
        return None
    return value.to_bytes(32, byteorder='big')


def generate_addresses(n_workers: int):
    """Generate valid ethereum addresses.

    Args:
        n_workers (int): number of addresses to generate
    Returns:
        int[]: the addresses are already converted to int
    """
    addresses = []
    for i in range(n_workers):
        private_key = keccak_256(token_bytes(32)).digest()
        public_key = PublicKey.from_valid_secret(
            private_key).format(compressed=False)[1:]
        addr = keccak_256(public_key).digest()[-20:]
        addresses.append(int(addr.hex(), 16))
    return addresses


def compute_model_weight(n_workers: int):
    """Generate an array of model weights.

    Args:
        n_workers (int): number of workers

    Returns:
        List[int]: the array of model hashes
    """
    # weights are good(42) for 4/5 of workers and 1/5 of workers are malicious(666)
    return [42 if i % 5 != 0 else 666 for i in range(n_workers)]


def compute_add_new_encrypted_model_hash(n_workers: int, addresses, model_weights):
    """Generate an array of model hashes. Model hashed is obtained by
    adding worker address (as an int) to model weight.

    Args:
        n_workers (int): number of workers
        addresses (int[]): array of worker addresses
        model_weights (int[]): array of model weights

    Returns:
        List[str]: the array of model hashes
    """
    return [Web3.solidityKeccak(["uint256"], [addresses[i] + model_weights[i]]).hex() for i in range(n_workers)]


n_workers = 10
addresses = generate_addresses(n_workers)
model_weights = compute_model_weight(n_workers)
add_new_encrypted_model_arg1 = compute_add_new_encrypted_model_hash(
    n_workers, addresses, model_weights)

add_new_encryption_model_counter = 0
add_verification_parameters_counter = 0

for line in sys.stdin:
    proto = ''
    arguments = ''

    matched = False
    # we set parameter from this file, so we expect no arguments in method received
    m = re.search('^getModelAndBatchIndex\(\)$', line)
    if m:
        proto = 'getModelAndBatchIndex()'
        matched = True
    if not matched:
        m = re.search('^addNewEncryptedModel\(\)$', line)
        if m:
            proto = 'addNewEncryptedModel(uint160,bytes32)'
            #arg0_value = 3
            # arg0 = encode_uint(arg0_value)
            #arg1 = encode_bytes32('abc')
            worker_address = addresses[add_new_encryption_model_counter]
            model_hashed_with_address = add_new_encrypted_model_arg1[add_new_encryption_model_counter]
            arg0 = encode_uint(worker_address)
            arg1 = encode_bytes32(model_hashed_with_address)
            arguments = base64.b64encode(arg0 + arg1).decode('ascii')
            add_new_encryption_model_counter += 1
            matched = True
    if not matched:
        m = re.search('^addVerificationParameters\(\)$', line)
        if m:
            #proto = 'addVerificationParameters(uint160,uint256)'
            proto = 'addVerificationParameters(address,uint256)'
            matched = True
            worker_address = 69
            arg0 = encode_uint(worker_address)
            model_weight = 1000  # Â model weight
            arg1 = encode_uint(model_weight)
            arguments = base64.b64encode(arg0 + arg1).decode('ascii')
            matched = True
    if not matched:
        # received line isn't a valid method (check yaml file and smart contract method name)
        exit(1)

    print(proto)
    print(arguments, flush=True)
