#!/usr/bin/env python3
#
# See: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html

import os
from concurrent.futures import ProcessPoolExecutor
import numpy as np
import base64
import re

# import struct
import sys
from secrets import token_bytes
from coincurve import PublicKey
from sha3 import keccak_256
from web3 import Web3
from eth_abi import encode_abi

import time


def encode_bytes32(value: str) -> str:
    b = value[2:].encode("utf-8")
    # check if the string is too long
    if len(b) / 2 > 32.0:
        raise ValueError("The string is too long to be encoded as bytes32.")
        return None
    # pad the string with 0s
    b += b"\x00" * (32 - len(b))
    return b


def encode_uint(value: int) -> str:
    # if value cannot be represented as uint256, raise an error
    if value < 0 or value > 2**256 - 1:
        raise ValueError("The value cannot be represented as uint256.")
        return None
    return value.to_bytes(32, byteorder="big")


def generate_addresses(n_workers: int):
    """Generate valid ethereum addresses.

    Args:
        n_workers (int): number of addresses to generate
    Returns:
        int[]: the addresses are already converted to int
    """
    addresses = []
    for i in range(n_workers):
        private_key = keccak_256(token_bytes(32)).digest()
        public_key = PublicKey.from_valid_secret(private_key).format(compressed=False)[
            1:
        ]
        addr = keccak_256(public_key).digest()[-20:]
        addresses.append(int(addr.hex(), 16))
    return addresses


def compute_model_weight(n_workers: int, model_length: int) -> [int]:
    """Generate an array of model weights.

    Args:
        n_workers (int): number of workers
        model_length (int): how much weights are in the model that is learned.

    Returns:
        [int]: the array of model weights
    """
    # weights are good(42) for 4/5 of workers and 1/5 of workers are malicious(666)
    return [
        [42] * model_length if i % 5 != 0 else [666] * model_length
        for i in range(n_workers)
    ]


# def compute_add_new_encrypted_model_hash(n_workers: int, addresses, good_model, bad_model):
#     """Generate an array of model hashes. Model hashed is obtained by
#     adding worker address (as an int) to model weight.

#     Args:
#         n_workers (int): number of workers
#         addresses (int[]): array of worker addresses
#         good_model (int[]): array of model weights
#         bad_model (int[]): array of model weights

#     Returns:
#         str[]: the array of model hashes
#     """
#     model_hashes = []
#     for i in range(n_workers):
#         worker_address = addresses[i]
#         if i % 5 != 0:
#             model_weights = good_model
#         else:
#             model_weights = bad_model
#         encrypted_model = [
#             weight + worker_address for weight in model_weights]
#         model_hashes.append(Web3.solidityKeccak(
#             ["uint256[]"], [encrypted_model]).hex())
#     return model_hashes


def compute_add_new_encrypted_model_hash(n_workers: int, addresses: [int], model_length: int) -> None:
    """Generate an array of model hashes. Model hashed is obtained by
    adding worker address (as an int) to model weight.

    Args:
        n_workers (int): number of workers that we want to generate model hashes for
        addresses (int[]): array of worker addresses
        model_length (int): how much weights are in the model that is learned.

    Returns:
        None
    """
    start_time = time.time()
    # how much weights are in the model that is learned.
    good_model = [42] * model_length
    bad_model = [666] * model_length
    with open("generated_args/arg_addNewEncryptedModel_{}_model_length.txt".format(model_length), "w") as f:
        for i in range(n_workers):
            worker_address = addresses[i]
            model_weights = good_model if i % 5 != 0 else bad_model
            model_hash = Web3.solidityKeccak(
                ["uint256[]"],
                [[weight + worker_address for weight in model_weights]]).hex()
            f.write(model_hash + "\n")
            print("written hashed:", i)
    # print("Time: ", time.time() - start_time)
    return None


def read_file(f_path):
    BLOCK_SIZE = 1024
    with open(file_path, 'rb') as f:
        previous_line = ""
        while True:
            block = f.read(BLOCK_SIZE)
            if block:
                lines = block.decode().splitlines()
                for line in lines:
                    if not line.startswith("0x"):
                        previous_line += line
                    else:
                        if previous_line:
                            yield previous_line
                        previous_line = line
            else:
                if previous_line:
                    yield previous_line
                return


# print("generating...")
start = time.time()
n_workers = 100
# model_length = 1_600_000  # For MNIST
# model_length = 100_000
model_length = 1_600_000
# model_length = 100
good_model = [42] * model_length
bad_model = [666] * model_length
addresses = generate_addresses(n_workers)
# TODO use this line only for pre-computation, otw you can read from a file
compute_add_new_encrypted_model_hash(n_workers, addresses, model_length)
print("generation done")

file_path = 'generated_args/arg_addNewEncryptedModel_{}_model_length.txt'.format(
    model_length)
lines = ["0x11111"]
x = read_file(file_path)
# for elem in x:
#     pass
# lines = list(read_file(file_path))

add_new_encryption_model_counter = 0
add_verification_parameters_counter = 0
# print("generation done...")

add_new_encryption_model_args_100_000 = [
    "0x18b12f584ecb2cfed8928fde11889d89fcab21a5e63d7488e1718ec78d3eab80", "0x0ab142359298abfa7623178fa80bf29c5b59c6efa47f176d5b0b602da99cf2d8", "0xfb3a515817d1fbee67d21c98003202bebb57dde190c5df6e2f57b2362467f425", "0x30f97a02de0f947eccc2921c8dfd0393feb997b1797a78c829f2f81d8659ce19", "0x38878d160eeabdc7c7fdec9545e6f220a46933740c0cc0b9eb6d4084328e6326", "0x59579c526105e57cc5447174be797487acd0c8d7a61efe803fecf5abd4228af9", "0xb63cd080ba79f612bf1a1466b5d92f7fa1c2c766d3d0c451b482185fbb1fed6a", "0xc95b12d0589140468c755c9576ec78c107633a1df5dcbe6350b01dc8e433fee1", "0x8ca8744ab1e8fb7534b649f172f8b4b2725b71b6dc879a88f171ed61038184b4", "0xef600a04e9b3906eb2c9bd62b469ed4652932698d6cd1fba7d73ca4593dc55c9", "0x79e4b5d0929819db02e69ae772d469df8c6368bb3a1785eea96cc312f40c3b75", "0x03250d4af263d4ef36fb858c321e76f46006f73123ee4ef8bb4480d9f6297c85", "0x14d8bd63558e12727e76498ff2b9465bdf82bef9752e8eeffb9596c89d7578ab", "0xcfc8a2141a305962ff8fae115f0fbd2d0f4d91e3c24bd70eedc614c1afe53f58", "0xee81c6ca20890ec8227d37e87867d35d846965af16aae920d1f055252fb348f9", "0x02d7011fc1109e8486374d56014117a6c9ad6591a04041d32d05b649b6c1771e", "0x0b0fafc8b9ec21e3525293572c9bd7d48429fdff4a870bf4b0b5126d6bcd1a7b", "0x6e1736c046c3319bcd3595f94e4edb8e61cbd507cc04c277439be756dfdd5e8e", "0xfdcd627c803d0118142789b6129e32d9090753b51d70a9713094edcf9d4f6022", "0x50ffbb93316ee3a8292e054cec9b773f8eed8fe522b7be9b236f68868f52ee20", "0xafab4d1ba0e82825a107a4c8838aaffcf3580ddac7334a677eea09188ca746ba", "0xa5d8773647929bd84f3900f2a274ca82647a0ba987e91a19b0258204b750a311", "0x5bc90e2a41fba710fc1d79016df3a0ac4a2e77f5f57c3ce16eeac62a620729c1", "0x70f0d7d100d289bc88664d53b9436948c2e684aa4a1faadcec76394af49e060f", "0xf941669e26595febb9a08746e73d305980fb4ea55e2e7318e187458cabd75d0b", "0x292d638efb185d7eaef0948d27290cba5c90bb133b752839cb05161480517df9", "0x6c2ff08f98b8224b3ff43780306b88e1b39448a1f31b91b7f57292c7aa39b04d", "0x21344519418dd948b0e59e153570e234fc726d00b8e1463a80fafb6742bd6894", "0x6b9258f3ecd2cb403253bea8d27fb60cdaa52904b5849f78c575402f27a5933e", "0x33436d9b9e8746e532024db41efa444de68c009552d6425fed6d64b408af77cc", "0x70c668a48f6fd1b914a0eedf22aa7390f5f9c0ca6293f2f090446333dfb74113", "0x601f598b0601b14ad4e4dd65461d30b147de9322643706f24a296fbbcbf033c4", "0xdbbc55d3838fe42d9b46c59008a2e0048e048f9b186974c0c97d35541f5bf5f4", "0xb02561bdac3904776b1cf248b9032ec930538c5f39209546316e0203e1bf61b0", "0xac61acafe9272ec5e7b0456350353e1a9ef1dd099e23498913fb299465a5b408", "0x0989f1bea2fcf3271a2c6065c891949009840efdc72d3c4de263393f3744691e", "0xeed8ab8cc2accd40a88dfc0544f4f746b6ffa3f5e33e71de6c5af3183ce8049e", "0x0cfc5057e53a5137e699491fd17a44cfeb5a67b068b9ea524352845f74f28b36", "0x40ec18ca0d4c360491f5f84ec9ba7b4ebbfff513a1708a13ab6680abdf35b2a2", "0xbbd48dbbc33dc6ee869ef43ed4f067f9a82d57bc29167621d417b8e287a71215", "0x968ff17240464d75c69f78c6b7fceb2fc14245a8911dc76837fe20baac7ec721", "0x6912d2e37b9ac3abf55040ad4604ea747081f2e0b0d0699dade1050c72a71a8c", "0xe387a34883f961f6baab9109533b8474555fc391e5d3f07d37e4670f29fd765f", "0x72e9e5e0ae76f20cc18b2747a4d427440efea33494cbbb37ad0b02b0074df1ab", "0x5dcbc5b779764b050e3dd7504a429ba59fc801952ece79c1c87dc4e0d8c929f4", "0x62250309038bd69aecf0e76165245dd11e099b0ba8b41f0168f1c9f3dfad1b66", "0xbc1f595e935eceb2a5b2e197d5dd6c316fef04428d05984a3b6158b08fc4ccba", "0xf0c2904ac9da0bbd50217da5a0fb2eb71a77eb0eecf1890f03b8d82f8c1dc14b", "0xf3302f3a42650ce973784e961427d38a7dedbecb89a879ebe04037ac6309430a", "0x8aecf631d973f9e02d42cc86c69cef8939953195055dca0ce05118c1060d6088", "0x948b73cf7b6ccc02265fd8607818a801126a87faac2d89cba682984d201c5e38", "0x3c3ced3f71e0cccbd8a0efc589cabb9239580f5dd76eb62efd8f9fa375853f2c", "0x67cfd13bc420711ae319debe796fb66f7132a9876765a9bdf80b64e8c5f977d0", "0x880521bf9b66fe23f8c90d6ba2673c45994eca1889983edd6fe4b096b2307c1b", "0xd865006b4a2c6e44dcd9e9adc78fff4aeedccd5f69d4019670efbc772991b442", "0x215acaa060e7a36565ccad9d28863eb146c70e42b0e931a7988ff25786f677c6", "0x005ae34b6b574e5b613c166cb5870536b967d13a302909cad2e9cadcddbd228b", "0x9a497bd3f2da36b83a49e60103da59c34fde04ba7f9aee6711625f3ac125a099", "0xaa24c22825daa6d9ca3b47ecc2ee5b4f770ea71f18f85112e7868989d42f382d", "0xd7668f785378521c433e8e9e978508380bf5019330a869418b9b436565ef3557", "0x6c9408ba81a1cd3bdcbb1ea9ff257061c890a0b7243fc7a3f818f523b925e689", "0x10e05f8ef40f25c2fe0de35878aa744690c9fead5bca8112cfc9b5b7289b2dd5", "0xcc037508116584b934f28f155ebe55fd0967b1b7a907b74a16cdde14134c56b3", "0x18a740a15b11862f70668704feb9a91ff5fd36ae6b74e683417b2a830f94dd10", "0xb8dcb0a4968dcdf94f69e84bd1c91cf101b78d3e2bde22669be23ac5b4f3a77d", "0xa7edf4afb3d5fb4654b3f44341e31fc8c008e11cb6e46ba69e90e481c45b24ec", "0xf850e3374e5b717a3af507fff26d529ff95dd3a40be1d727184b260c646a0305", "0x7e46672568bb19c5844f08c985ec6921f1a1e1e397588f678a0beb584c4e83a1", "0x529ae46ebb643cba287db534a68d358013aa842b82297f033167b53bd386229a", "0x91c5b58b649e283bfc2642140df55cb5d313d22884716d94874ec7eb5849acc3", "0x2ec793d67d11a52026f53d154bd61ffb0a02b0301d177f1c18c1c3a34f3d25ae", "0xbb6106ecee53fdd919233068fd9607d32663411f82e0730d137d061914f8b926", "0x591a0559cbebd80029d9d4972b6c3c8a18bb7a5d54e21113f4417bcef086c97c", "0x668495e3a98f803ad58cc7c230bd7edfe4b1077f67968f0da83fa07a7ccc80e1", "0x0bc23504abdec5fae00626ecb120ae34a4db39bbd73977d4ca908db0d8b32fe9", "0x2bcd023c1b51a5f9e1dffc1eba15d44dc26b66431a64641eabc23a25df869d17", "0xe194b5b9e9cca11575adb10dcd1757647e66cc74307a1fdc1db57e57d7e46680", "0x8378fcb028e995a8876bcc35b3fe9946cdd62da101860e0e8ff4a8348c0d395f", "0x36e10e06d64a704a66cef6a8a1b8ee84c1c6c9b9efc20bb3f96cc14fb81c5f74", "0xeaee85f199da62fa59f12a2efffea1a3c3a2bf941d33e629cd595f10ba6315c8", "0x078eea4d9f4c3eabb3dce4ea063a44ad1fdc3e917641fb3ba79befeed52e7458", "0xe04f327d42d65dbb71427ad1322dfe1832a411ec5ac2445d1cec590ad04fce91", "0xab4bc4f195c2e4534cbcd3eba542197e377c9ce05a00132714578140a8988586", "0x874e286f6e82217879e679537de0d31b106726dfc7b4807f0d55a2a3a123856e", "0xeaf46342128b7c2ae4b3b872b31b5b2941f769a3f8253d74bed3d7811faee5f8", "0xbf7ca18ec4f6ef669fc0cc37a809c71e53a7b6fdc6d3bab7a817c0d8ff5dbfba", "0x714fc793591ea0aa1c2140a5d13c26cab2bc1bf5324e6bbdbaa85fc336b4f331", "0x8e90feb093321f9a7c7451b58d77fcb72199d5a96610b6fd2e32fc2397b5f4e4", "0xe5fff4122ee1a78921049c52301906189fdb8b6ce2589245fa237d4d970e47cd", "0x60db9869b8c5736203a027018694cf71b7dd936864505f0c47e080d7ee3ef352", "0xa22a7548cf2b00254b2271cc501a2ad1b8726495c0bce7cc2ca90faf6656c68e", "0x9a252f3e936fdd965720c2c3f05f4cbc38b59cfd406b07f08d52992e6cb23013", "0x2613d3a60e0193f90ad3eec27d6bf9b5aa996dcf0676582d0631b2e94c0fea61", "0x72d9a53e72ef27b36360d574f69f0e90af0b26527b01457e11e7419be4aa4ab4", "0x7b5590c667192b9ee3458ebac43c1de4f8c9cdf78cc4e15ea0b12123e6c23e36", "0x9ddd7e8db0c7e945b0cb4aeb9858dc63c94db2b890a84d779da445325e925b13", "0x8f154d006c7f98875a0354da250d7452b2ef263c3127ff4c11d8ee585756ff09", "0x15d8c6af2d56be8775eca38ce75b725fb29c6ccecaaad7b904518a344ba915a6", "0xf643dc0199561fafaebe879babece7700bfc438fe294a4aeadbd2d1669a87fbd", "0xa0bebe0bcfff60dafcfe72d55c35b9a4ef402b7a929270fbcacba08c37f9d20e"
]

for line in sys.stdin:
    proto = ""
    arguments = ""

    matched = False
    # we set parameter from this file, so we expect no arguments in method received
    m = re.search("^getModelAndBatchIndex\(\)$", line)
    if m:
        proto = "getModelAndBatchIndex()"
        matched = True
    if not matched:
        m = re.search("^addNewEncryptedModel\(\)$", line)
        if m:
            proto = "addNewEncryptedModel(uint160,bytes32)"
            worker_address = addresses[add_new_encryption_model_counter]
            model_hashed_with_address = add_new_encryption_model_args_100_000[0]
            arg0 = encode_uint(worker_address)
            arg1 = encode_bytes32(model_hashed_with_address)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            # modulo to reuse the same arguments for other learn task (reduce pre-computation time which is high)
            add_new_encryption_model_counter = (
                1 + add_new_encryption_model_counter) % n_workers
            matched = True
    if not matched:
        m = re.search("^addVerificationParameters\(\)$", line)
        if m:
            proto = "addVerificationParameters(uint256[])"
            worker_address = addresses[add_verification_parameters_counter]
            # worker_weights = model_weights[add_verification_parameters_counter]
            # TODO print 5 seconds lonf for 100k param so see with 1.6 millions...
            worker_weights = good_model if add_verification_parameters_counter % 5 != 0 else bad_model
            encoded_array = encode_abi(
                ["int256[]"], [[worker_address] + worker_weights]
            )
            arguments = base64.b64encode(encoded_array).decode("ascii")
            # modulo to reuse the same arguments for other learn task (reduce pre-computation time which is high)
            add_verification_parameters_counter = (
                1 + add_verification_parameters_counter) % n_workers
            matched = True
    if not matched:
        # in that case we are checking if the arguments are correct (i.e we expect infinite loop if args no corrects)
        m = re.search("^checkAddressEncoding\(\)$", line)
        if m:
            proto = "checkAddressEncoding(uint160)"
            matched = True
            # the one expected by checkAddressEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            arg0 = encode_uint(true_worker_address)
            # arg0 = encode_uint(false_worker_address)
            arguments = base64.b64encode(arg0).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkUint160AndBytes32\(\)$", line)
        if m:
            proto = "checkUint160AndBytes32(uint160,bytes32)"
            # proto = 'checkUint160AndBytes32(uint160,uint160)'
            matched = True
            # the one expected by checkUintEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            true_model_hash_with_address = (
                "0xe72c25d7ca23adf3090d18988974cb4633e9261db2fb0a4a4d5d703a19cd356d"
            )
            false_model_hash_with_address = (
                "0xe72c25d7ca23adf3090d18988974cb4633e9261db2fb0a4a4d5d703a19cd356e"
            )
            arg0 = encode_uint(true_worker_address)
            # arg1 = encode_bytes32(true_model_hash_with_address)
            arg1 = encode_bytes32(false_model_hash_with_address)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkUint160AndUint256\(\)$", line)
        if m:
            proto = "checkUint160AndUint256(uint160,uint256)"
            matched = True
            # the one expected by checkUintEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            true_model_weight = 42
            false_model_weight = 666
            arg0 = encode_uint(true_worker_address)
            # arg0 = encode_uint(false_worker_address)
            arg1 = encode_uint(true_model_weight)
            # arg1 = encode_uint(false_model_weight)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkDynamicUint256Array\(\)$", line)
        if m:
            proto = "checkDynamicUint256Array(uint256[])"
            true_worker_address = 725016507395605870152133310144839532665846457513
            true_array = [true_worker_address, 1, 2, 3, 4, 5]
            false_array_0 = [
                725016507395605870152133310144839532665846457513,
                1,
                2,
                3,
                4,
                6,
            ]
            false_array_1 = [
                725016507395605870152133310144839532665846457513,
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                7,
                5,
                3,
            ]
            false_array_2 = [66666666666666666, 1, 2, 3, 4, 5]
            # encoded_array = encode_abi(['int256[]'], [true_array])
            # encoded_array = encode_abi(['int256[]'], [false_array_0])
            # encoded_array = encode_abi(['int256[]'], [false_array_1])
            encoded_array = encode_abi(["int256[]"], [false_array_2])
            arguments = base64.b64encode(encoded_array).decode("ascii")
            matched = True
    if not matched:
        # received line isn't a valid method (check yaml file and smart contract method name)
        exit(1)

    # we can print the fonction and the arguments
    print(proto)
    print(arguments, flush=True)
