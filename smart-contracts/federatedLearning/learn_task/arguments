#!/usr/bin/env python3
#
# See: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html

from concurrent.futures import ProcessPoolExecutor
import numpy as np
import base64
import re

# import struct
import sys
from secrets import token_bytes
from coincurve import PublicKey
from sha3 import keccak_256
from web3 import Web3
from eth_abi import encode_abi

import time


def encode_bytes32(value: str) -> str:
    b = value[2:].encode("utf-8")
    # check if the string is too long
    if len(b) / 2 > 32.0:
        raise ValueError("The string is too long to be encoded as bytes32.")
        return None
    # pad the string with 0s
    b += b"\x00" * (32 - len(b))
    return b


def encode_uint(value: int) -> str:
    # if value cannot be represented as uint256, raise an error
    if value < 0 or value > 2**256 - 1:
        raise ValueError("The value cannot be represented as uint256.")
        return None
    return value.to_bytes(32, byteorder="big")


def generate_addresses(n_workers: int):
    """Generate valid ethereum addresses.

    Args:
        n_workers (int): number of addresses to generate
    Returns:
        int[]: the addresses are already converted to int
    """
    addresses = []
    for i in range(n_workers):
        private_key = keccak_256(token_bytes(32)).digest()
        public_key = PublicKey.from_valid_secret(private_key).format(compressed=False)[
            1:
        ]
        addr = keccak_256(public_key).digest()[-20:]
        addresses.append(int(addr.hex(), 16))
    return addresses


def compute_model_weight(n_workers: int, model_length: int) -> [int]:
    """Generate an array of model weights.

    Args:
        n_workers (int): number of workers
        model_length (int): how much weights are in the model that is learned.

    Returns:
        [int]: the array of model weights
    """
    # weights are good(42) for 4/5 of workers and 1/5 of workers are malicious(666)
    return [
        [42] * model_length if i % 5 != 0 else [666] * model_length
        for i in range(n_workers)
    ]


# def hash_model_with_address(worker_address: int, model_weights: [int]) -> str:
#     return Web3.solidityKeccak(
#         ["uint256[]"], [[weight + worker_address for weight in model_weights]]).hex()


def compute_add_new_encrypted_model_hash(n_workers: int, addresses, good_model, bad_model):
    """Generate an array of model hashes. Model hashed is obtained by
    adding worker address (as an int) to model weight.

    Args:
        n_workers (int): number of workers
        addresses (int[]): array of worker addresses
        good_model (int[]): array of model weights
        bad_model (int[]): array of model weights

    Returns:
        str[]: the array of model hashes
    """
    model_hashes = []
    for i in range(n_workers):
        worker_address = addresses[i]
        if i % 5 != 0:
            model_weights = good_model
        else:
            model_weights = bad_model
        encrypted_model = [
            weight + worker_address for weight in model_weights]
        model_hashes.append(Web3.solidityKeccak(
            ["uint256[]"], [encrypted_model]).hex())
    return model_hashes


def compute_add_new_encrypted_model_hash(n_workers: int, addresses: [int], model_length: int) -> None:
    """Generate an array of model hashes. Model hashed is obtained by
    adding worker address (as an int) to model weight.

    Args:
        n_workers (int): number of workers that we want to generate model hashes for
        addresses (int[]): array of worker addresses
        model_length (int): how much weights are in the model that is learned.

    Returns:
        None
    """
    start_time = time.time()
    # how much weights are in the model that is learned.
    good_model = [42] * model_length
    bad_model = [666] * model_length
    with open("generated_args/arg_addNewEncryptedModel_{}_model_length.txt".format(model_length), "w") as f:
        for i in range(n_workers):
            worker_address = addresses[i]
            model_weights = good_model if i % 5 != 0 else bad_model
            model_hash = Web3.solidityKeccak(
                ["uint256[]"],
                [[weight + worker_address for weight in model_weights]]).hex()
            f.write(model_hash + "\n")
    print("Time: ", time.time() - start_time)
    return None


print("generating...")
start = time.time()
n_workers = 100
model_length = 1_600_000  # For MNIST
# model_length = 100_000
# model_length = 100
good_model = [42] * model_length
bad_model = [666] * model_length
addresses = generate_addresses(n_workers)
# TODO use this line only for pre-computation, otw you can read from a file
compute_add_new_encrypted_model_hash(n_workers, addresses, model_length)


add_new_encryption_model_counter = 0
add_verification_parameters_counter = 0
print("generation done...")

for line in sys.stdin:
    proto = ""
    arguments = ""

    matched = False
    # we set parameter from this file, so we expect no arguments in method received
    m = re.search("^getModelAndBatchIndex\(\)$", line)
    if m:
        proto = "getModelAndBatchIndex()"
        matched = True
    if not matched:
        m = re.search("^addNewEncryptedModel\(\)$", line)
        if m:
            proto = "addNewEncryptedModel(uint160,bytes32)"
            worker_address = addresses[add_new_encryption_model_counter]
            # we read the argument from the pre-computed files
            model_hashed_with_address = open("generated_args/arg_addNewEncryptedModel_{}_model_length.txt".format(
                model_length)).readlines()[add_new_encryption_model_counter].strip()
            arg0 = encode_uint(worker_address)
            arg1 = encode_bytes32(model_hashed_with_address)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            # modulo to reuse the same arguments for other learn task (reduce pre-computation time which is high)
            add_new_encryption_model_counter = (
                1 + add_new_encryption_model_counter) % n_workers
            matched = True
    if not matched:
        m = re.search("^addVerificationParameters\(\)$", line)
        if m:
            proto = "addVerificationParameters(uint256[])"
            worker_address = addresses[add_verification_parameters_counter]
            # worker_weights = model_weights[add_verification_parameters_counter]
            # TODO print 5 seconds lonf for 100k param so see with 1.6 millions...
            worker_weights = good_model if add_verification_parameters_counter % 5 != 0 else bad_model
            encoded_array = encode_abi(
                ["int256[]"], [[worker_address] + worker_weights]
            )
            arguments = base64.b64encode(encoded_array).decode("ascii")
            # modulo to reuse the same arguments for other learn task (reduce pre-computation time which is high)
            add_verification_parameters_counter = (
                1 + add_verification_parameters_counter) % n_workers
            matched = True
    if not matched:
        # in that case we are checking if the arguments are correct (i.e we expect infinite loop if args no corrects)
        m = re.search("^checkAddressEncoding\(\)$", line)
        if m:
            proto = "checkAddressEncoding(uint160)"
            matched = True
            # the one expected by checkAddressEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            arg0 = encode_uint(true_worker_address)
            # arg0 = encode_uint(false_worker_address)
            arguments = base64.b64encode(arg0).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkUint160AndBytes32\(\)$", line)
        if m:
            proto = "checkUint160AndBytes32(uint160,bytes32)"
            # proto = 'checkUint160AndBytes32(uint160,uint160)'
            matched = True
            # the one expected by checkUintEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            true_model_hash_with_address = (
                "0xe72c25d7ca23adf3090d18988974cb4633e9261db2fb0a4a4d5d703a19cd356d"
            )
            false_model_hash_with_address = (
                "0xe72c25d7ca23adf3090d18988974cb4633e9261db2fb0a4a4d5d703a19cd356e"
            )
            arg0 = encode_uint(true_worker_address)
            # arg1 = encode_bytes32(true_model_hash_with_address)
            arg1 = encode_bytes32(false_model_hash_with_address)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkUint160AndUint256\(\)$", line)
        if m:
            proto = "checkUint160AndUint256(uint160,uint256)"
            matched = True
            # the one expected by checkUintEncoding
            true_worker_address = 725016507395605870152133310144839532665846457513
            false_worker_address = 725016507395605870152133310144839532665846457512
            true_model_weight = 42
            false_model_weight = 666
            arg0 = encode_uint(true_worker_address)
            # arg0 = encode_uint(false_worker_address)
            arg1 = encode_uint(true_model_weight)
            # arg1 = encode_uint(false_model_weight)
            arguments = base64.b64encode(arg0 + arg1).decode("ascii")
            matched = True
    if not matched:
        m = re.search("^checkDynamicUint256Array\(\)$", line)
        if m:
            proto = "checkDynamicUint256Array(uint256[])"
            true_worker_address = 725016507395605870152133310144839532665846457513
            true_array = [true_worker_address, 1, 2, 3, 4, 5]
            false_array_0 = [
                725016507395605870152133310144839532665846457513,
                1,
                2,
                3,
                4,
                6,
            ]
            false_array_1 = [
                725016507395605870152133310144839532665846457513,
                1,
                2,
                3,
                5,
                6,
                7,
                8,
                7,
                5,
                3,
            ]
            false_array_2 = [66666666666666666, 1, 2, 3, 4, 5]
            # encoded_array = encode_abi(['int256[]'], [true_array])
            # encoded_array = encode_abi(['int256[]'], [false_array_0])
            # encoded_array = encode_abi(['int256[]'], [false_array_1])
            encoded_array = encode_abi(["int256[]"], [false_array_2])
            arguments = base64.b64encode(encoded_array).decode("ascii")
            matched = True
    if not matched:
        # received line isn't a valid method (check yaml file and smart contract method name)
        exit(1)

    # we can print the fonction and the arguments
    print(proto)
    print(arguments, flush=True)
