#!/usr/bin/env python3
#
# See: https://docs.soliditylang.org/en/v0.8.11/abi-spec.html

import base64
import re
import struct
import sys
from secrets import token_bytes
from coincurve import PublicKey
from sha3 import keccak_256


def encode_bytes32(value: str) -> str:
    b = value.encode('utf-8')
    # check if the string is too long
    if len(b) > 32:
        raise ValueError("The string is too long to be encoded as bytes32.")
        return None
    # pad the string with 0s
    b += b'\x00' * (32 - len(b))
    return b


def encode_uint(value: int) -> str:
    # if value cannot be represented as uint256, raise an error
    if value < 0 or value > 2**256 - 1:
        raise ValueError("The value cannot be represented as uint256.")
        return None
    return value.to_bytes(32, byteorder='big')


def generate_addresses(n_workers: int):
    """Generate valid ethereum addresses.

    Returns:
        int[]: the addresses are already converted to int
    """
    addresses = []
    for i in range(10):
        private_key = keccak_256(token_bytes(32)).digest()
        public_key = PublicKey.from_valid_secret(
            private_key).format(compressed=False)[1:]
        addr = keccak_256(public_key).digest()[-20:]
        addresses.append(int(addr.hex(), 16))
    return addresses


# def compute_model_hash() -> List[int]:
#     """Generate an array of random model hashes.
#     Hashes are between 10000 and 10000 + n_workers.

#     Args:
#         n_workers (int): number of model hashes to generate

#     Returns:
#         List[int]: the array of model hashes
#     """
#     return [i for i in range(10000, 10000 + n_workers)]


n_workers = 10
addresses = generate_addresses(n_workers)
get_parameter_counter = 0
add_new_encryption_model_counter = 0
add_verification_parameters_counter = 0

for line in sys.stdin:
    proto = ''
    arguments = ''

    matched = False
    # we set parameter from this file, so we expect no arguments in method received
    m = re.search('^getModelAndBatchIndex\(\)$', line)
    if m:
        proto = 'getModelAndBatchIndex()'
        #arguments = ''
        matched = True
    if not matched:
        m = re.search('^addNewEncryptedModel\(\)$', line)
        if m:
            proto = 'addNewEncryptedModel(uint160,bytes32)'
            matched = True
            arg0_value = 3
            arg0 = encode_uint(arg0_value)
            arg1 = encode_bytes32('abc')
            #arg1 = b'abc\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
            # args = [encode_uint160_as_function_call(
            #    arg0), encode_bytes32(arg1)]
            #arguments = encode_args_as_function_call(args)
            # x = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x03'
            # x = arg0.to_bytes(32, byteorder='big')
            # x = base64.b64encode(x).decode('ascii')
            # arguments = base64.b64encode(x + x).decode('ascii')
            # arguments = base64.b64encode(arg1).decode('ascii') woking for bytes32
            arguments = base64.b64encode(arg0 + arg1).decode('ascii')
    if not matched:
        m = re.search('^addVerificationParameters\(\)$', line)
        if m:
            #proto = 'addVerificationParameters(uint160,uint256)'
            proto = 'addVerificationParameters(address,uint256)'
            matched = True
            worker_address = 69
            arg0 = encode_uint(worker_address)
            model_weight = 1000  # Â model weight
            arg1 = encode_uint(model_weight)
            arguments = base64.b64encode(arg0 + arg1).decode('ascii')
            matched = True
    if not matched:
        # received line isn't a valid method (check yaml file and smart contract method name)
        exit(1)

    print(proto)
    print(arguments, flush=True)
